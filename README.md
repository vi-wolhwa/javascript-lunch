# javascript-lunch

우아한테크코스 레벨1 점심 뭐 먹지 미션

### 🌐 [Git Page](https://vi-wolhwa.github.io/javascript-lunch/dist/)

</br>

# 1단계 리팩토링(1)

1단계 리팩토링 후, 주요 변경사항과 질문을 정리한 섹션입니다.

</br>

## 1. 웹 컴포넌트

이번 미션의 학습 목표는 컴포넌트를 사용하는 것이 아니었습니다. 그러나 꼭 공부해보고 싶어서 공부 후 적용해보게 되었습니다.

### 1-1. Component 추상클래스

모든 컴포넌트의 Base 컴포넌트를 추상클래스로 선언하습니다. 컴포넌트의 쉬운 확장에 초점을 맞추었고, 필수 메서드만 구현하도록 구조를 간단히 하였습니다.

### 1-2. 컴포넌트 재분리

컴포넌트를 분리하는 기준을 분명히 하였습니다.

- 독립적인 기능으로 동작 가능한 경우
- HTML 요소 측면에서 재사용성이 있는 경우
- 의미적으로 관련된 컴포넌트를 묶는 경우

### 📌 1-3. 컴포넌트간 종속성 최소화

다른 컴포넌트의 요소 등을 서로 모르도록 구현하고자 했지만 완벽히 반영되지 않았습니다. 각 컴포넌트 마다 이벤트에 대한 규약(API)를 정해놓고, 규약에 따라 통신하도록 구현하고 싶었으나, 이를 위해서 이벤트 컨트롤러를 선언해야 했습니다. 이벤트를 캐치한 후, 다른 컴포넌트를 향해 이벤트를 dispatch하는 과정이 과하다고 느꼈습니다. 리액트를 경험해보지 않아서 리액트의 동작 방식은 모르지만, **웹 컴포넌트에서는 계층 관계가 아닌 컴포넌트와의 완벽한 독립성을 추구하는 것이 옳은지 궁금합니다.**

### 📌 1-4. 도메인의 필요성

각 컴포넌트는 컨트롤러의 역할을 수행하고 있고, 데이터 정렬은 `RestDataAPI` 서비스를 통해 구현하였습니다. 컴포넌트가 도메인과 데이터를 주고 받을 떄 의존성이 강하다고 느꼈기 때문입니다. 이에 대하여 피드백을 받고 싶습니다.

</br>

## 2. 커스텀 이벤트

커스텀 이벤트를 사용하지 않는 방향을 생각해보았지만, 다음의 이유로 다시 사용하게 되었습니다.

### 2-1. 이벤트 발신자 판단 문제

애플리케이션에서는 수많은 이벤트가 버블링되어 전역으로 전파됩니다. 네이티브 이벤트들은 종류가 많지 않기 때문에, 발신자를 이용해 구분하고 싶었습니다. 그러나 네이티브 이벤트에 발신자 정보를 삽입하는 것이 어려웠고, **2-2**의 문제가 발생하였습니다.

### 2-2. event.target 문제

이벤트 수신자에서 `event.target`를 호출하면 원하지 않는 데이터를 반환받습니다. 예를 들어, 헤더의 음식점 추가 버튼을 클릭했을 때 `event.target`는 버튼이 아닌 버튼 내부의 이미지 입니다. 이벤트 수신자를 판단할 때, 내부 요소를 비교하는 것이 부적절하다고 느꼈습니다.

</br>

## 3. Type, Constant 관리

구현 중 사용한 상수와 타입의 종류가 많지 않기 때문에, 각각 하나의 파일에 정리하였습니다. (types.ts와 constants.ts). 실무에서는 타입과 상수를 어떤 방식으로 분리하고 관리하는지 궁금했지만 의미있는 정보를 서칭할 수 없었습니다.

</br>

# 2단계 변동사항

</br>

## 1. 컴포넌트

### 1-1. 웹 컴포넌트 제거

1단계에서는 '웹 컴포넌트'가 무엇인지 알지 못하고, 다른 크루들을 따라 사용하였습니다. 수업을 통해 함수형 컴포넌트 방식에 대해 알게 되었고, 함수형 프로그래밍을 해보고자 처음부터 다시 리팩토링 하게 되었습니다.

### 1.2. 컴포넌트 분류

너무 많은 컴포넌트가 하나의 폴더 내에 있기 때문에 가독성이 떨어졌습니다. 따라서 아래 기준에 따라 컴포넌트를 분류하였습니다.

- unit
  - 최소 기능 단위로 분리한 컴포넌트
  - 컴포넌트의 속성을 외부에서 주입
- others
  - 의미론적으로 분리한 컴포넌트
  - 컴포넌트의 속성을 내부에서 지정

## 📌 2. 컨트롤러

"컴포넌트는 컨트롤러다."라고 생각하였으나, 다음의 이유로 컨트롤러를 생성하게 되었습니다.

- 컴포넌트 간 통신 (이벤트 의존 통신의 대안)
- 복잡한 기능의 분리

하나의 기능 코드가 복잡할 경우(list에 item 렌더링)와 컴포넌트 간 잦은 통신이 필요한 경우를 컨트롤러가 관리합니다. 주로 컴포넌트 간 통신 문제를 해결합니다. 기존의 이벤트에 의존한 컴포넌트간 통신을 전역(Global)에 초기화하여 사용하도록 하였습니다. 소스코드가 직관적으로 개선되었다고 생각합니다. `전역에서 컨트롤러를 관리하는 것이 옳은지`에 대한 리뷰어님의 의견을 듣고 싶습니다.
